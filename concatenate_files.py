#!/usr/bin/env python3
"""
File Concatenation Script for Statistical Arbitrage Project

This script concatenates all primary Python files in the project into a single file,
excluding __init__.py files and files in __pycache__ directories.
"""

import os
import sys
from pathlib import Path
from typing import List, Set
import argparse
from datetime import datetime


def should_exclude_file(file_path: Path) -> bool:
    """
    Determine if a file should be excluded from concatenation.
    
    Args:
        file_path: Path to the Python file
        
    Returns:
        True if file should be excluded, False otherwise
    """
    # Exclude patterns
    exclude_patterns = {
        '__init__.py',
        '__pycache__',
        '.pyc',
        '.pyo',
        '.pyd',
        'test_',
        '_test.py',
        '.git',
        '.env',
        'venv',
        '.venv'
    }
    
    # Check if any exclude pattern matches
    file_str = str(file_path).lower()
    for pattern in exclude_patterns:
        if pattern in file_str:
            return True
    
    return False


def get_python_files(root_dir: Path, include_scripts: bool = True) -> List[Path]:
    """
    Get all Python files in the project directory.
    
    Args:
        root_dir: Root directory to search
        include_scripts: Whether to include files in scripts directory
        
    Returns:
        List of Python file paths
    """
    python_files = []
    
    for file_path in root_dir.rglob('*.py'):
        if should_exclude_file(file_path):
            continue
            
        # Skip scripts directory if not included
        if not include_scripts and 'scripts' in file_path.parts:
            continue
            
        python_files.append(file_path)
    
    # Sort files for consistent output
    python_files.sort()
    return python_files


def read_file_content(file_path: Path) -> str:
    """
    Read the content of a Python file.
    
    Args:
        file_path: Path to the Python file
        
    Returns:
        File content as string
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except UnicodeDecodeError:
        # Try with latin-1 encoding as fallback
        try:
            with open(file_path, 'r', encoding='latin-1') as f:
                return f.read()
        except Exception as e:
            return f"# Error reading file {file_path}: {e}\n"
    except Exception as e:
        return f"# Error reading file {file_path}: {e}\n"


def create_file_header(file_path: Path, relative_path: Path) -> str:
    """
    Create a header for each file section in the concatenated output.
    
    Args:
        file_path: Absolute path to the file
        relative_path: Relative path from project root
        
    Returns:
        Header string
    """
    separator = "=" * 80
    return f"""
{separator}
# FILE: {relative_path}
# Full path: {file_path}
{separator}

"""


def concatenate_files(root_dir: Path, output_file: Path, include_scripts: bool = True) -> None:
    """
    Concatenate all Python files into a single file.
    
    Args:
        root_dir: Root directory of the project
        output_file: Path to the output file
        include_scripts: Whether to include files in scripts directory
    """
    python_files = get_python_files(root_dir, include_scripts)
    
    if not python_files:
        print("No Python files found to concatenate.")
        return
    
    print(f"Found {len(python_files)} Python files to concatenate.")
    
    with open(output_file, 'w', encoding='utf-8') as outf:
        # Write file header
        outf.write(f"""#!/usr/bin/env python3
'''
CONCATENATED PYTHON FILES - Statistical Arbitrage Project
Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Total files: {len(python_files)}

This file contains all primary Python files from the project concatenated together.
Generated by concatenate_files.py

WARNING: This is an automatically generated file. Do not edit directly.
'''

""")
        
        # Process each file
        for i, file_path in enumerate(python_files, 1):
            try:
                relative_path = file_path.relative_to(root_dir)
                print(f"Processing {i}/{len(python_files)}: {relative_path}")
                
                # Write file header
                outf.write(create_file_header(file_path, relative_path))
                
                # Write file content
                content = read_file_content(file_path)
                outf.write(content)
                
                # Add spacing between files
                outf.write("\n\n")
                
            except Exception as e:
                error_msg = f"# Error processing {file_path}: {e}\n\n"
                outf.write(error_msg)
                print(f"Error processing {file_path}: {e}")
    
    print(f"\nConcatenation complete!")
    print(f"Output file: {output_file}")
    print(f"Total size: {output_file.stat().st_size / 1024:.1f} KB")


def main():
    """Main function to handle command line arguments and execute concatenation."""
    parser = argparse.ArgumentParser(
        description="Concatenate Python files from the Statistical Arbitrage project"
    )
    parser.add_argument(
        '--output', '-o',
        type=str,
        default='concatenated_project.py',
        help='Output file name (default: concatenated_project.py)'
    )
    parser.add_argument(
        '--no-scripts',
        action='store_true',
        help='Exclude files from scripts directory'
    )
    parser.add_argument(
        '--root-dir', '-r',
        type=str,
        help='Root directory to search (default: current directory)'
    )
    
    args = parser.parse_args()
    
    # Determine root directory
    if args.root_dir:
        root_dir = Path(args.root_dir).resolve()
    else:
        root_dir = Path(__file__).parent.resolve()
    
    # Create output file path
    output_file = Path(args.output).resolve()
    
    print(f"Root directory: {root_dir}")
    print(f"Output file: {output_file}")
    print(f"Include scripts: {not args.no_scripts}")
    print("-" * 50)
    
    # Check if root directory exists
    if not root_dir.exists():
        print(f"Error: Root directory {root_dir} does not exist.")
        sys.exit(1)
    
    # Ask for confirmation if output file exists
    if output_file.exists():
        response = input(f"Output file {output_file} already exists. Overwrite? (y/N): ")
        if response.lower() != 'y':
            print("Operation cancelled.")
            sys.exit(0)
    
    # Perform concatenation
    try:
        concatenate_files(root_dir, output_file, include_scripts=not args.no_scripts)
    except Exception as e:
        print(f"Error during concatenation: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
